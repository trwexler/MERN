Arrow Functions

Understanding and utilizing anonymous functions is important to becoming a skilled JavaScript developer. An anonymous function is simply a function without a name. ES6 introduces a new shortened syntax for writing anonymous functions that is the focus of this chapter.
Function Keyword

Consider a simple sayHello function assigned to a variable.

var sayHello = function(name) {
  console.log('Hello ' + name);
};

Utilizing ES6 arrow functions, colloquially fat arrow functions, we can rewrite it as such:

const sayHello = (name) => {
  console.log(`Hello ${name}`);
};

Notice we've omitted the function keyword and now have an arrow (=>) pointing to the function body. Interesting, but what benefits does this provide other than less typing?

For simple methods we can refine this example further. Single parameters don't need parenthesis and with the function body being a single statement we can remove the curly braces.

const sayHello = name => console.log(`Hello ${name}`);

Concise. More complex functions will need a more complete body ({}), and multiple parameters will require parenthesis. Another benefit of utilizing arrow functions for simple expressions is implicit returns. Let's create a new example.

var square = function(n) {
  return n * n;
};

will become

const square = n => n * n;

Traditional functions require explicit returns, such as in the first square. With arrow functions the result of our expression, n * n, is implicitly returned to the caller. 


Arrow functions give us the ability to shorten the syntax of returning an object as well however, there is one piece of syntax we need in order to return an object. Let's look at the example below. 

// longhand notation to return an object
// NOTE: first set of brackets are defining the function body
// and the second set of brackets are to create the object literal
const returnObjLonghand = () => {
    return { 
        firstName: 'John',
        lastName: 'Wick'
    }
}
/**
  * The example below wouldn't work because the 
  * brackets are interpreted as opening the body of the 
  * function rather than brackets to create an object literal 
  */
const returnObj = () => { firstName: 'John', lastName: 'Wick' }
// surrounding the implicit return with parenthesis solves the problem
const returnObjFixed = () => ({ firstName: 'John', lastName: 'Wick' });

Context

Fancy syntax isn't the only change with arrow functions. They also inherit context from the parent scope. To demonstrate this let's create a card Deck class.

class Deck {
  constructor() {
    const suits = ['Diamond', 'Heart', 'Spade', 'Club'];
    const faces = ['Ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King'];
    const deck = [];
    for (const suit of suits) {
      for (const face of faces) {
        deck.push(this.createCard(suit, face));
      }
    }
    this.deck = deck;
  }
  createCard(suit, face) {
    return face + " of " + suit;
  }
}

We'll start refactoring for a more functional approach using forEach, but continue using traditional anonymous functions.

class Deck {
  constructor() {
    const suits = ['Diamond', 'Heart', 'Spade', 'Club'];
    const faces = ['Ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King'];
    const deck = [];
    suits.forEach(function(suit) {
      faces.forEach(function(face) {
        deck.push(this.createCard(suit, face));
      });
    });
    this.deck = deck;
  }
  createCard(suit, face) {
    return face + " of " + suit;
  }
}

Creating a new Deck will now result in a TypeError: TypeError: Cannot read property 'createCard' of undefined, because this in our anonymous functions don't have the same context as our loops.

We can fix this issue with arrow functions like so:

class Deck {
  constructor() {
    ... 
    suits.forEach(suit => {
      faces.forEach(face => {
        deck.push(this.createCard(suit, face));
      });
    });
  }
  createCard(suit, face) {
    return face + " of " + suit;
  }
}

Arrow functions don't create their own context, it looks to the enclosing scope for that information. Therefore this should now refer to the Deck instance, which has a createCard method
Conclusion

Arrow functions provide a simpler syntax with implicit returns for succinct expressions. Additionally they inherit context from parent scopes. While this is great much of the time there are instances when you want context to change, so be aware of how an arrow function might affect your code.




<body id="body">
    <h1>My Boring Website</h1>
    <p id="paragraph">
        This website is boring, with very little CSS. 
        However, we really just care about the javascript. 
        For example, if you click <button id="button">this button</button>, the background of this paragraph tag will change to blue.
    </p>
    <p>We also have a <button id="alert">alert</button> button that will grab the text from the input below and show it in a popup.</p>
    <div>
        <input type="text" id="popup-input">
    </div>
    <p>
        We just like random interactivity in the site, including a fun effect if you hover over <span id="hover-this">        <b>this.</b></span>
    </p>
    <p onmouseover="mouseOverFunction(this)">
        Another task: This should be another feature. 
        I want to click anywhere in this paragraph tag and I want to be able to change the background color to whatever is in this input: <input type="text"/>.
    </p>
    <script>
        document.getElementById("button").onclick = function() {
            setBackgroundColorById("paragraph", "blue");
        }
        document.getElementById("alert").onclick = function(){
            alert(document.getElementById("popup-input").value);
        }
        document.getElementById("hover-this").onmouseover = function(){
            setBackgroundColorById("body", "red");
        }
        document.getElementById("hover-this").onmouseout = function(){
            setBackgroundColorById("body", "white");
        }
        function getValueFromId(id){
            return document.getElementById(id).value;
        }
        function setBackgroundColorById(id, color){
            document.getElementById(id).style = "background-color: " + color;
        }
        function mouseOverFunction(el){
            el.style = "background-color: black";
        }
    </script>
</body>
</html>




IN ES6 IS:


body id="body">
    <h1>My Boring Website</h1>
    <p id="paragraph">
        This website is boring, with very little CSS. 
        However, we really just care about the javascript. 
        For example, if you click <button id="button">this button</button>, the background of this paragraph tag will change to blue.
    </p>
    <p>We also have a <button id="alert">alert</button> button that will grab the text from the input below and show it in a popup.</p>
    <div>
        <input type="text" id="popup-input">
    </div>
    <p>
        We just like random interactivity in the site, including a fun effect if you hover over <span id="hover-this"><b>this.</b></span>
    </p>
    <!-- Added an id attribute to this paragraph because the "setBackgroundColorById" needs two parameters: id and color -->
    <p onmouseover="mouseOverFunction(this)" id="set-color" onclick="setBackgroundColorById()">
        Another task: This should be another feature. 
        I want to click anywhere in this paragraph tag and I want to be able to change the background color to whatever is in this input: <input type="text" id="color-input"/>.
    </p>
    <script>
        document.getElementById("button").onclick = () =>  {
            setBackgroundColorById("paragraph", "blue");
        }
        document.getElementById("alert").onclick = () => {
            alert(document.getElementById("popup-input").value);
        }
        document.getElementById("hover-this").onmouseover = () => {
            setBackgroundColorById("body", "red");
        }
        document.getElementById("hover-this").onmouseout = () => {
            setBackgroundColorById("body", "white");
        }
        function getValueFromId(id){
            return document.getElementById(id).value;
        }
        // refactored function, hard coding the p and input ids into the function below
        const setBackgroundColorById = () => {
            document.getElementById("set-color").style = "background-color: " + document.getElementById("color-input").value;
        }
        const mouseOverFunction = (el) => {
            el.style = "background-color: black";
        }
    </script>
</body>
</html>














